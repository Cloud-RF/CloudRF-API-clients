<!DOCTYPE html>
<html lang="en">

<head>
    <title>CloudRF Area Leaflet Demo</title>
    <link 
        rel="stylesheet" 
        href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
        integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
        crossorigin="" />
    <link 
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" 
        rel="stylesheet" 
        integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" 
        crossorigin="anonymous">
    <link rel="stylesheet" href="CloudRF.css">

    <style>
        .legend {
            background: white;
            padding: 6px 8px;
            font: 14px/16px sans-serif;
        }
        .legend .legend-title {
            padding-bottom: 6px;
            font: 16px/18px sans-serif;
        }
        .legend .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        .legend .legend-color {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            flex-shrink: 0;
        }
        .legend .legend-label {
            flex: 1;
        }
    </style>
</head>

<body class="p-2">
    <h1>CloudRF Direction Finding Leaflet Demo</h1>

    <div class="alert alert-danger d-none" role="alert" id="dangerAlert"></div>

    <div class="input-group input-group-sm mb-3">
        <span class="input-group-text">API Key</span>
        <input id="apiKey" type="password" class="form-control" placeholder="Your API Key for service defined below.">
    </div>

    <div class="input-group input-group-sm mb-3">
        <span class="input-group-text">API Service Base URL</span>
        <input id="apiServiceBaseUrl" type="text" class="form-control" value="https://api.cloudrf.com" placeholder="The base URL of where your API requests will be made to.">
    </div>

    <p>Enter your API key above and then click on the map to...?</p>
    <p><a href="index.html">Click here</a> to see reference documentation and other demos.</p>

    <div class="row align-items-center">
        <div class="col-auto">
            <label for="slider-received-power">Received Power (dBm)</label>
            <input type="range" min="-110" max="-60" value="-100" class="slider" id="slider-received-power"/>
            <label for ="slider-received-power" id="label-received-power-value"></label>
        </div>

        <div class="col"></div>

        <div class="col-auto text-end">
            <label for="slider-tx-power">Tx Power (W)</label>
            <input type="range" min="0.1" max="4" value="2" step="0.1" class="slider" id="slider-tx-power"/>
            <label for ="slider-tx-power" id="label-tx-power-value"></label>
        </div>
    </div>

    <div id="mapArea" class="map"></div>


    <div class="d-flex justify-content-between">
        <div class="w-50 mx-4">
            <h2>Request</h2>

            <pre id="requestRawOutput" class="p-3 bg-dark text-white font-monospace overflow-x-scroll">No data to show yet...</pre>
        </div>
        <div class="w-50 mx-4">
            <h2>Response</h2>

            <pre id="responseRawOutput" class="p-3 bg-dark text-white font-monospace overflow-x-scroll">No data to show yet...</pre>
        </div>
    </div>

    <script 
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" 
        integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" 
        crossorigin="anonymous"></script>
    <script
        src="https://code.jquery.com/jquery-3.6.3.min.js"
        integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU="
        crossorigin="anonymous"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
        integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
        crossorigin=""></script>
    <script src="CloudRF.js"></script>

    <script>

        const EARTH_RADIUS_M = 6371000;

        const TEMPLATE = {
            "network": "Direction-finding-demo",
            "site": "DF",
            "engine": 2,
            "transmitter": {
                "alt": 15,
                "frq": 800,
                "txw": 0.5,
                "bwi": 0.1
            },
            "receiver": {
                "lat": 0,
                "lon": 0,
                "alt": 1,
                "rxg": 0,
                "rxs": 200
            },
            "antenna": {
                "txg": 2.15,
                "txl": 0,
                "ant": 1,
                "azi": 0,
                "tlt": 0,
                "hbw": 0,
                "vbw": 0,
                "pol": "v",
                "fbr": 0
            },
            "model": {
                "pm": 1,
                "pe": 2,
                "ked": 1,
                "rel": 50
            },
            "environment": {
                "clt": "Minimal.clt",
                "elevation": 1,
                "landcover": 1,
                "buildings": 0,
                "obstacles": 0
            },
            "output": {
                "units": "m",
                "col": "9",
                "out": 1,
                "ber": 0,
                "mod": 0,
                "nf": -140,
                "res": 30,
                "rad": 15
            }
        };

        const ARC_DEG = 10;

        const ARC_LINE_LENGTH = 1e5;
        const ARC_LINE_OPTIONS = {
            color: '#000000',
            weight: 1,
        }
        
        const COLOR_KEY = [
            {receivedPowerMargin: 2, red: 255, green: 0, blue: 0},
            {receivedPowerMargin: 5, red: 255, green: 128, blue: 0},
            {receivedPowerMargin: 10, red: 0, green: 255, blue: 0},
        ];

        var map = L.map('mapArea').setView([38.916, 1.448], 12);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        var directionFinder = L.marker(
            L.latLng(38.91823165617842, 1.452081140147925), 
            { 
                title: 'DF',
                draggable: 'true', 
                icon: L.icon({
                    iconUrl: 'images/tower.png',
                    iconSize: [40, 40],
                    iconAnchor:   [20, 20],
                    popupAnchor:  [20, 20]
                })
            }
        ).addTo(map);

        var targetLatLng = null; 

        var areaCanvas = document.createElement('canvas');
        var areaBounds = null;

        var segmentCanvas = document.createElement('canvas');

        function toRad (d) {
            return d * Math.PI / 180;
        }

        function toDeg (r) {
            return r * 180 / Math.PI;
        }

        function bearingBetween(a, b) {
            const deltaLng = toRad(b.lng) - toRad(a.lng);

            const y = Math.cos(toRad(b.lat)) * Math.sin(deltaLng);
            const x = Math.cos(toRad(a.lat)) * Math.sin(toRad(b.lat)) - Math.sin(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.cos(deltaLng);

            return (toDeg(Math.atan2(y, x)) + 360) % 360;
        }

        function endpointFromPointBearingDistance(point, bearing, distance) {
            const angularDistance = distance / EARTH_RADIUS_M;
            const lat = Math.asin(Math.sin(toRad(point.lat)) * Math.cos(angularDistance) + Math.cos(toRad(point.lat)) * Math.sin(angularDistance) * Math.cos(toRad(bearing)));
            const lng = toRad(point.lng) + Math.atan2(Math.sin(toRad(bearing)) * Math.sin(angularDistance) * Math.cos(toRad(point.lat)), Math.cos(angularDistance) - Math.sin(toRad(point.lat)) * Math.sin(lat));

            return L.latLng(toDeg(lat), toDeg(lng)).wrap();
        }

        function pixelLatLng(width, height, bounds, x, y) {
            let lat = bounds.getNorth() + (bounds.getSouth() - bounds.getNorth()) * (y + 0.5) / height;
            let lng = bounds.getWest() + (bounds.getEast() - bounds.getWest()) * (x + 0.5) / width;
            return L.latLng(lat, lng);
        }

        function pointInArc(arcOrigin, arcTarget, arcDeg, point) {
            let dO = point.distanceTo(arcOrigin);
            let dT = point.distanceTo(arcTarget);
            let dOT = arcTarget.distanceTo(arcOrigin);

            let cosTheta = (dO * dO + dOT * dOT - dT * dT) / (2 * dOT * dO);
            let cosHalfArcDeg = Math.cos(toRad(arcDeg / 2));

            return cosTheta >= cosHalfArcDeg;
        }

        function drawArcLines() {
            map.eachLayer(layer => {
                if (layer.name === "line") {
                    map.removeLayer(layer);
                }
            });

            const bearing = bearingBetween(directionFinder.getLatLng(), targetLatLng);
            const leftBearing  = bearing - ARC_DEG / 2;
            const rightBearing = bearing + ARC_DEG / 2;

            const leftEnd = endpointFromPointBearingDistance(directionFinder.getLatLng(), leftBearing, ARC_LINE_LENGTH);
            const rightEnd = endpointFromPointBearingDistance(directionFinder.getLatLng(), rightBearing, ARC_LINE_LENGTH);

            const left = L.polyline([directionFinder.getLatLng(), leftEnd], ARC_LINE_OPTIONS).addTo(map);
            left.name = "line";

            const right = L.polyline([directionFinder.getLatLng(), rightEnd], ARC_LINE_OPTIONS).addTo(map);
            right.name = "line";
        }

        async function runDfAreaCalc() {
            let request = {...TEMPLATE};

            let latLng = directionFinder.getLatLng();

            request.transmitter.lat = latLng.lat;
            request.transmitter.lon = latLng.lng;

            console.log(request);

            let requestJson = JSON.stringify(request, null, 4);

            $('#requestRawOutput').html(requestJson);
            $('#responseRawOutput').html("Sending...");

            validateApiKey();

            let response = await fetch(`${apiServiceBaseUrl}/area`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'key': apiKey
                },
                body: requestJson
            });

            let responseJson = await response.json();
            $('#responseRawOutput').html(JSON.stringify(responseJson, null, 4));

            const img = new Image();
            img.crossOrigin = 'Anonymous';

            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = responseJson.PNG_WGS84;
            });

            areaCanvas.width = img.width;
            areaCanvas.height = img.height;

            const ctx = areaCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            areaBounds = L.latLngBounds(
                L.latLng(responseJson.bounds[2], responseJson.bounds[3]),
                L.latLng(responseJson.bounds[0], responseJson.bounds[1]),
            );

            await runDf();
        }

        async function runDf() {
            if (areaBounds === null) return;
            if (targetLatLng === null) return;

            drawArcLines();

            segmentCanvas.width = areaCanvas.width;
            segmentCanvas.height = areaCanvas.height;
            const ctx = segmentCanvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(areaCanvas, 0, 0);

            const imageData = ctx.getImageData(0, 0, segmentCanvas.width, segmentCanvas.height);
            const data = imageData.data;
            for (let y = 0; y < segmentCanvas.height; y++) {
                for (let x = 0; x < segmentCanvas.width; x++) {

                    let i = (y * segmentCanvas.width + x) * 4;

                    latLng = pixelLatLng(segmentCanvas.width, segmentCanvas.height, areaBounds, x, y);

                    if (!pointInArc(directionFinder.getLatLng(), targetLatLng, ARC_DEG, latLng)) {
                        data[i + 3] = 0;
                    }

                    if (data[i + 3] != 0) {
                        let pathloss = data[i + 0];

                        let tx_power_dbm = 30 + 10 * Math.log10($('#slider-tx-power').val());
                        let rx_power_dbm = tx_power_dbm - pathloss;

                        let difference = Math.abs(rx_power_dbm - $('#slider-received-power').val());

                        let first_color_key_entry = COLOR_KEY.find((entry) => entry.receivedPowerMargin >= difference);

                        if (first_color_key_entry) {
                            data[i + 0] = first_color_key_entry.red;
                            data[i + 1] = first_color_key_entry.green;
                            data[i + 2] = first_color_key_entry.blue;
                        } else {
                            data[i + 3] = 0;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0 ,0);

            map.eachLayer(layer => {
                if (layer.name === "df") {
                    map.removeLayer(layer);
                }
            });

            const layer = L.imageOverlay (
                segmentCanvas.toDataURL(),
                areaBounds,
                { opacity: 0.7 },
            ).addTo(map);
            layer.name = "df";
        }

        function buildColorKeyLegend() {

            var legend = L.control({ position: 'bottomright' });

            legend.onAdd = function (map) {
                var legend = $('<div class="legend"></div>');

                var title = $('<div class="legend-title">Margin (dB)</div>');
                legend.append(title);

                COLOR_KEY.forEach(entry => {
                    entry.receivedPowerMargin

                    var item = $('<div class="legend-item"></div>');
                    var colorBox = $('<span class="legend-color"></span>').css('background', `rgb(${entry.red}, ${entry.green}, ${entry.blue})`);
                    var label = $('<span class="legend-label"></span>').text(entry.receivedPowerMargin);

                    item.append(colorBox);
                    item.append(label);
                    legend.append(item);
                })

                return legend[0];
            };

            legend.addTo(map);
        }

        directionFinder.on('dragend', e => {
            console.log(directionFinder.getLatLng());
            runDfAreaCalc();
        })

        map.on('click', e => {
            targetLatLng = e.latlng;
            runDf();
        })

        $('#slider-received-power').on('change', e => {
            $('#label-received-power-value').text($('#slider-received-power').val());
            runDf();
        })
        $('#slider-tx-power').on('change', e => {
            $('#label-tx-power-value').text($('#slider-tx-power').val());
            runDf();
        })

        $('#apiKey').on('change', e => {
            if (apiKey) {
                runDfAreaCalc();
            }
        })

        $('#slider-received-power').change();
        $('#slider-tx-power').change();

        buildColorKeyLegend();


    </script>
</body>

</html>